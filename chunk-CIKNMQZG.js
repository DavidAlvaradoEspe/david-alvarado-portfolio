import{b as M}from"./chunk-BIUUBQVG.js";import{l as x,o as b,u as _,v as T}from"./chunk-VF226S3Z.js";import{d as p}from"./chunk-D7E25M7D.js";import{f as g,g as a}from"./chunk-ZIF4NNI2.js";import{a as u}from"./chunk-L3UYHT7M.js";var S="gpuTransformVertexShader",E=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
out vec3 outPosition;const mat4 identity=mat4(
vec4(1.0,0.0,0.0,0.0),
vec4(0.0,1.0,0.0,0.0),
vec4(0.0,0.0,1.0,0.0),
vec4(0.0,0.0,0.0,1.0)
);void main(void) {vec3 positionUpdated=position;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
mat4 finalWorld=identity;
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;u.ShadersStore[S]||(u.ShadersStore[S]=E);var B="gpuTransformPixelShader",V=`#version 300 es
void main() {discard;}
`;u.ShadersStore[B]||(u.ShadersStore[B]=V);var c=class m{constructor(e){this._buffers={},this._effects={},this._meshListCounter=0,this._engine=e}processAsync(e){return Array.isArray(e)||(e=[e]),this._meshListCounter=0,this._processMeshList(e),Promise.resolve()}_processMeshList(e){let s=this._engine.getCaps().parallelShaderCompile;this._engine.getCaps().parallelShaderCompile=void 0;for(let r=0;r<e.length;++r){let t=e[r];if(t.getTotalVertices()===0||!t.getVertexBuffer||!t.getVertexBuffer(a.PositionKind))continue;let o,i=[],n=[a.PositionKind];t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton?(n.push(a.MatricesIndicesKind),n.push(a.MatricesWeightsKind),t.numBoneInfluencers>4&&(n.push(a.MatricesIndicesExtraKind),n.push(a.MatricesWeightsExtraKind)),i.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),i.push("#define BONETEXTURE "+t.skeleton.isUsingTextureForMatrices),i.push("#define BonesPerMesh "+(t.skeleton.bones.length+1))):i.push("#define NUM_BONE_INFLUENCERS 0");let l=t.morphTargetManager?x(t.morphTargetManager,i,n,t,!0,!1,!1,!1,!1,!1):0,h=t.bakedVertexAnimationManager;h&&h.isEnabled&&(i.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),_(n,t,i));let d=i.join(`
`);if(this._effects[d])o=this._effects[d];else{let A={attributes:n,uniformsNames:["boneTextureWidth","mBones","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime"],uniformBuffersNames:[],samplers:["boneSampler","morphTargets","bakedVertexAnimationTexture"],defines:d,fallbacks:null,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:l},maxSimultaneousLights:0,transformFeedbackVaryings:["outPosition"]};o=this._engine.createEffect("gpuTransform",A,this._engine),this._effects[d]=o}this._compute(t,o)}this._engine.getCaps().parallelShaderCompile=s}_compute(e,s){let r=this._engine,t,f=e.getTotalVertices();if(this._buffers[e.uniqueId])t=this._buffers[e.uniqueId];else{let n=new Float32Array(f*3);t=new g(e.getEngine(),n,!0,3),this._buffers[e.uniqueId]=t}s.getEngine().enableEffect(s),e._bindDirect(s,null,!0),T(e,s),b(e,s),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(s);let o=e.bakedVertexAnimationManager;o&&o.isEnabled&&e.bakedVertexAnimationManager?.bind(s,!1);let i=t.getData();if(r.bindTransformFeedbackBuffer(t.getBuffer()),r.setRasterizerState(!1),r.beginTransformFeedback(!0),r.drawArraysType(2,0,f),r.endTransformFeedback(),r.setRasterizerState(!0),r.readTransformFeedbackBuffer(i),r.bindTransformFeedbackBuffer(null),this._meshListCounter===0)e._refreshBoundingInfo(i,null);else{let n=e.getBoundingInfo().boundingBox,l=M(i,0,f);m._Min.copyFrom(n.minimum).minimizeInPlace(l.minimum),m._Max.copyFrom(n.maximum).maximizeInPlace(l.maximum),e._refreshBoundingInfoDirect({minimum:m._Min,maximum:m._Max})}}registerMeshListAsync(e){return Array.isArray(e)||(e=[e]),this._meshList=e,this._meshListCounter=0,Promise.resolve()}processMeshList(){this._meshList.length!==0&&(this._processMeshList(this._meshList),this._meshListCounter++)}fetchResultsForMeshListAsync(){return this._meshListCounter=0,Promise.resolve()}dispose(){for(let e in this._buffers)this._buffers[e].dispose();this._buffers={},this._effects={},this._engine=null}};c._Min=new p;c._Max=new p;export{c as a};
