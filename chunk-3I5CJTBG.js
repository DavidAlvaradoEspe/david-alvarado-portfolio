import{a as _,b as w}from"./chunk-NPZEPKVW.js";import{c as m,d as f,e as V,f as h,g as y}from"./chunk-FWZ75RMU.js";import{a as M}from"./chunk-XXSLHR3E.js";import{a as x}from"./chunk-3WG2WLZ4.js";import{a as N}from"./chunk-CJK33JLH.js";var g=(()=>{class o{constructor(r){this.value=this._toInt(r)}_toInt(r){return r|0}add(r){return new o(this.value+r.value)}subtract(r){return new o(this.value-r.value)}multiply(r){return new o(Math.imul(this.value,r.value))}divide(r){return new o(this.value/r.value)}getClassName(){return o.ClassName}equals(r){return this.value===r.value}static FromValue(r){return new o(r)}toString(){return this.value.toString()}}return o.ClassName="FlowGraphInteger",o})();x("FlowGraphInteger",g);var l=class o{constructor(t=[1,0,0,1]){this._m=t}get m(){return this._m}transformVector(t){return this.transformVectorToRef(t,new m)}transformVectorToRef(t,r){return r.x=t.x*this._m[0]+t.y*this._m[1],r.y=t.x*this._m[2]+t.y*this._m[3],r}asArray(){return this.toArray()}toArray(t=[]){for(let r=0;r<4;r++)t[r]=this._m[r];return t}fromArray(t){for(let r=0;r<4;r++)this._m[r]=t[r];return this}multiplyToRef(t,r){let e=t._m,n=this._m,i=r._m;return i[0]=e[0]*n[0]+e[1]*n[2],i[1]=e[0]*n[1]+e[1]*n[3],i[2]=e[2]*n[0]+e[3]*n[2],i[3]=e[2]*n[1]+e[3]*n[3],r}multiply(t){return this.multiplyToRef(t,new o)}divideToRef(t,r){let e=this._m,n=t._m,i=r._m;return i[0]=e[0]/n[0],i[1]=e[1]/n[1],i[2]=e[2]/n[2],i[3]=e[3]/n[3],r}divide(t){return this.divideToRef(t,new o)}addToRef(t,r){let e=this._m,n=t.m,i=r.m;return i[0]=e[0]+n[0],i[1]=e[1]+n[1],i[2]=e[2]+n[2],i[3]=e[3]+n[3],r}add(t){return this.addToRef(t,new o)}subtractToRef(t,r){let e=this._m,n=t.m,i=r.m;return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],i[3]=e[3]-n[3],r}subtract(t){return this.subtractToRef(t,new o)}transpose(){let t=this._m;return new o([t[0],t[2],t[1],t[3]])}determinant(){let t=this._m;return t[0]*t[3]-t[1]*t[2]}inverse(){let t=this.determinant();if(t===0)throw new Error("Matrix is not invertible");let r=this._m,e=1/t;return new o([r[3]*e,-r[1]*e,-r[2]*e,r[0]*e])}equals(t,r=0){let e=this._m,n=t.m;return r===0?e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]:Math.abs(e[0]-n[0])<r&&Math.abs(e[1]-n[1])<r&&Math.abs(e[2]-n[2])<r&&Math.abs(e[3]-n[3])<r}getClassName(){return"FlowGraphMatrix2D"}toString(){return`FlowGraphMatrix2D(${this._m.join(", ")})`}},d=class o{constructor(t=[1,0,0,0,1,0,0,0,1]){this._m=t}get m(){return this._m}transformVector(t){return this.transformVectorToRef(t,new f)}transformVectorToRef(t,r){let e=this._m;return r.x=t.x*e[0]+t.y*e[1]+t.z*e[2],r.y=t.x*e[3]+t.y*e[4]+t.z*e[5],r.z=t.x*e[6]+t.y*e[7]+t.z*e[8],r}multiplyToRef(t,r){let e=t._m,n=this._m,i=r.m;return i[0]=e[0]*n[0]+e[1]*n[3]+e[2]*n[6],i[1]=e[0]*n[1]+e[1]*n[4]+e[2]*n[7],i[2]=e[0]*n[2]+e[1]*n[5]+e[2]*n[8],i[3]=e[3]*n[0]+e[4]*n[3]+e[5]*n[6],i[4]=e[3]*n[1]+e[4]*n[4]+e[5]*n[7],i[5]=e[3]*n[2]+e[4]*n[5]+e[5]*n[8],i[6]=e[6]*n[0]+e[7]*n[3]+e[8]*n[6],i[7]=e[6]*n[1]+e[7]*n[4]+e[8]*n[7],i[8]=e[6]*n[2]+e[7]*n[5]+e[8]*n[8],r}multiply(t){return this.multiplyToRef(t,new o)}divideToRef(t,r){let e=this._m,n=t.m,i=r.m;return i[0]=e[0]/n[0],i[1]=e[1]/n[1],i[2]=e[2]/n[2],i[3]=e[3]/n[3],i[4]=e[4]/n[4],i[5]=e[5]/n[5],i[6]=e[6]/n[6],i[7]=e[7]/n[7],i[8]=e[8]/n[8],r}divide(t){return this.divideToRef(t,new o)}addToRef(t,r){let e=this._m,n=t.m,i=r.m;return i[0]=e[0]+n[0],i[1]=e[1]+n[1],i[2]=e[2]+n[2],i[3]=e[3]+n[3],i[4]=e[4]+n[4],i[5]=e[5]+n[5],i[6]=e[6]+n[6],i[7]=e[7]+n[7],i[8]=e[8]+n[8],r}add(t){return this.addToRef(t,new o)}subtractToRef(t,r){let e=this._m,n=t.m,i=r.m;return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],i[3]=e[3]-n[3],i[4]=e[4]-n[4],i[5]=e[5]-n[5],i[6]=e[6]-n[6],i[7]=e[7]-n[7],i[8]=e[8]-n[8],r}subtract(t){return this.subtractToRef(t,new o)}toArray(t=[]){for(let r=0;r<9;r++)t[r]=this._m[r];return t}asArray(){return this.toArray()}fromArray(t){for(let r=0;r<9;r++)this._m[r]=t[r];return this}transpose(){let t=this._m;return new o([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}determinant(){let t=this._m;return t[0]*(t[4]*t[8]-t[5]*t[7])-t[1]*(t[3]*t[8]-t[5]*t[6])+t[2]*(t[3]*t[7]-t[4]*t[6])}inverse(){let t=this.determinant();if(t===0)throw new Error("Matrix is not invertible");let r=this._m,e=1/t;return new o([(r[4]*r[8]-r[5]*r[7])*e,(r[2]*r[7]-r[1]*r[8])*e,(r[1]*r[5]-r[2]*r[4])*e,(r[5]*r[6]-r[3]*r[8])*e,(r[0]*r[8]-r[2]*r[6])*e,(r[2]*r[3]-r[0]*r[5])*e,(r[3]*r[7]-r[4]*r[6])*e,(r[1]*r[6]-r[0]*r[7])*e,(r[0]*r[4]-r[1]*r[3])*e])}equals(t,r=0){let e=this._m,n=t.m;return r===0?e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]&&e[3]===n[3]&&e[4]===n[4]&&e[5]===n[5]&&e[6]===n[6]&&e[7]===n[7]&&e[8]===n[8]:Math.abs(e[0]-n[0])<r&&Math.abs(e[1]-n[1])<r&&Math.abs(e[2]-n[2])<r&&Math.abs(e[3]-n[3])<r&&Math.abs(e[4]-n[4])<r&&Math.abs(e[5]-n[5])<r&&Math.abs(e[6]-n[6])<r&&Math.abs(e[7]-n[7])<r&&Math.abs(e[8]-n[8])<r}getClassName(){return"FlowGraphMatrix3D"}toString(){return`FlowGraphMatrix3D(${this._m.join(", ")})`}};var a=class{constructor(t,r,e=-1){this.typeName=t,this.defaultValue=r,this.animationType=e}serialize(t){t.typeName=this.typeName,t.defaultValue=this.defaultValue}},C=new a("any",void 0),S=new a("string",""),R=new a("number",0,0),B=new a("boolean",!1),b=new a("Vector2",m.Zero(),5),A=new a("Vector3",f.Zero(),1),G=new a("Vector4",V.Zero()),P=new a("Matrix",y.Identity(),3),Q=new a("Matrix2D",new l),E=new a("Matrix3D",new d),F=new a("Color3",_.Black(),4),q=new a("Color4",new w(0,0,0,0),7),T=new a("Quaternion",h.Identity(),2);T.typeTransformer=o=>{if(o.getClassName){if(o.getClassName()==="Vector4")return h.FromArray(o.asArray());if(o.getClassName()==="Vector3")return h.FromEulerVector(o);if(o.getClassName()==="Matrix")return h.FromRotationMatrix(o)}return o};var k=new a("FlowGraphInteger",new g(0),0);function rt(o){let t=o;switch(typeof o){case"string":return S;case"number":return R;case"boolean":return B;case"object":if(t.getClassName)switch(t.getClassName()){case"Vector2":return b;case"Vector3":return A;case"Vector4":return G;case"Matrix":return P;case"Color3":return F;case"Color4":return q;case"Quaternion":return T;case"FlowGraphInteger":return k;case"Matrix2D":return Q;case"Matrix3D":return E}return C;default:return C}}function L(o){switch(o){case"string":return S;case"number":return R;case"boolean":return B;case"Vector2":return b;case"Vector3":return A;case"Vector4":return G;case"Matrix":return P;case"Color3":return F;case"Color4":return q;case"Quaternion":return T;case"FlowGraphInteger":return k;case"Matrix2D":return Q;case"Matrix3D":return E;default:return C}}function nt(o){switch(o){case"number":return 0;case"Vector2":return 5;case"Vector3":return 1;case"Matrix":return 3;case"Color3":return 4;case"Color4":return 7;case"Quaternion":return 2;default:return 0}}function ot(o){switch(o){case 0:return R;case 5:return b;case 1:return A;case 3:return P;case 4:return F;case 7:return q;case 2:return T;default:return C}}function U(o){return o==="Mesh"||o==="AbstractMesh"||o==="GroundMesh"||o==="InstanceMesh"||o==="LinesMesh"||o==="GoldbergMesh"||o==="GreasedLineMesh"||o==="TrailMesh"}function $(o){return o==="Vector2"||o==="Vector3"||o==="Vector4"||o==="Quaternion"||o==="Color3"||o==="Color4"}function Z(o){return o==="Matrix"||o==="Matrix2D"||o==="Matrix3D"}function O(o){return o==="AnimationGroup"}function J(o,t,r=!1){if(o==="Vector2")return m.FromArray(t);if(o==="Vector3")return r&&(t[2]*=-1),f.FromArray(t);if(o==="Vector4")return V.FromArray(t);if(o==="Quaternion")return r&&(t[2]*=-1,t[3]*=-1),h.FromArray(t);if(o==="Color3")return new _(t[0],t[1],t[2]);if(o==="Color4")return new w(t[0],t[1],t[2],t[3]);throw new Error(`Unknown vector class name ${o}`)}function I(o,t,r){let e=t?.getClassName?.()??"";if($(e)||Z(e))r[o]={value:t.asArray(),className:e};else if(e==="FlowGraphInteger")r[o]={value:t.value,className:e};else if(e&&(t.id||t.name))r[o]={id:t.id,name:t.name,className:e};else if(typeof t!="object")r[o]=t;else throw new Error(`Could not serialize value ${t}`)}function K(o,t,r,e){let n=t[o],i,u=n?.type??n?.className;if(U(u)){let c=e.meshes.filter(s=>n.id?s.id===n.id:s.name===n.name);c.length===0&&(c=e.transformNodes.filter(s=>n.id?s.id===n.id:s.name===n.name)),i=n.uniqueId?c.find(s=>s.uniqueId===n.uniqueId):c[0]}else if($(u))i=J(u,n.value);else if(O(u)){let c=e.animationGroups.filter(s=>s.name===n.name);i=c.length===1?c[0]:c.find(s=>s.uniqueId===n.uniqueId)}else u==="Matrix"?i=y.FromArray(n.value):u==="Matrix2D"?i=new l(n.value):u==="Matrix3D"?i=new d(n.value):u==="FlowGraphInteger"?i=g.FromValue(n.value):u==="number"||u==="string"||u==="boolean"?i=n.value[0]:n&&n.value!==void 0?i=n.value:Array.isArray(n)?i=n.reduce((c,s)=>(s.eventData&&(c[s.id]={type:L(s.type)},typeof s.value<"u"&&(c[s.id].value=K("value",s,r,e))),c),{}):i=n;return i}function mt(o){return o==="FlowGraphJsonPointerParserBlock"}var D=class{constructor(t,r,e){this._ownerBlock=e,this._connectedPoint=[],this.uniqueId=M(),this.connectedPointIds=[],this.name=t,this._connectionType=r}get connectionType(){return this._connectionType}_isSingularConnection(){return!0}isConnected(){return this._connectedPoint.length>0}connectTo(t){if(this._connectionType===t._connectionType)throw new Error(`Cannot connect two points of type ${this.connectionType}`);if(this._isSingularConnection()&&this._connectedPoint.length>0||t._isSingularConnection()&&t._connectedPoint.length>0)throw new Error("Max number of connections for point reached");this._connectedPoint.push(t),t._connectedPoint.push(this)}disconnectFrom(t,r=!0){let e=this._connectedPoint.indexOf(t),n=t._connectedPoint.indexOf(this);e===-1||n===-1||(r&&this._connectedPoint.splice(e,1),t._connectedPoint.splice(n,1))}disconnectFromAll(){for(let t of this._connectedPoint)this.disconnectFrom(t,!1);this._connectedPoint.length=0}dispose(){for(let t of this._connectedPoint)this.disconnectFrom(t)}serialize(t={}){t.uniqueId=this.uniqueId,t.name=this.name,t._connectionType=this._connectionType,t.connectedPointIds=[],t.className=this.getClassName();for(let r of this._connectedPoint)t.connectedPointIds.push(r.uniqueId)}getClassName(){return"FGConnection"}deserialize(t){this.uniqueId=t.uniqueId,this.name=t.name,this._connectionType=t._connectionType,this.connectedPointIds=t.connectedPointIds}};var p=class extends D{constructor(t,r,e,n,i=n.defaultValue,u=!1){super(t,r,e),this.richType=n,this._defaultValue=i,this._optional=u,this._isDisabled=!1,this._lastValue=null,this.dataTransformer=null,this.onValueChangedObservable=new N}get optional(){return this._optional}get isDisabled(){return this._isDisabled}set isDisabled(t){this._isDisabled!==t&&(this._isDisabled=t,this._isDisabled&&this.disconnectFromAll())}_isSingularConnection(){return this.connectionType===0}setValue(t,r){r._getConnectionValue(this)!==t&&(r._setConnectionValue(this,t),this.onValueChangedObservable.notifyObservers(t))}resetToDefaultValue(t){t._setConnectionValue(this,this._defaultValue)}connectTo(t){this._isDisabled||super.connectTo(t)}_getValueOrDefault(t){let r=t._getConnectionValue(this)??this._defaultValue;return this.dataTransformer?this.dataTransformer(r):r}getValue(t){if(this.connectionType===1){t._notifyExecuteNode(this._ownerBlock),this._ownerBlock._updateOutputs(t);let e=this._getValueOrDefault(t);return this._lastValue=e,this.richType.typeTransformer?this.richType.typeTransformer(e):e}let r=this.isConnected()?this._connectedPoint[0].getValue(t):this._getValueOrDefault(t);return this._lastValue=r,this.richType.typeTransformer?this.richType.typeTransformer(r):r}_getLastValue(){return this._lastValue}getClassName(){return"FlowGraphDataConnection"}serialize(t={}){super.serialize(t),t.richType={},this.richType.serialize(t.richType),t.optional=this._optional,I("defaultValue",this._defaultValue,t)}};x("FlowGraphDataConnection",p);var v=class{constructor(t){this.config=t,this.uniqueId=M(),this.name=this.config?.name??this.getClassName(),this.dataInputs=[],this.dataOutputs=[]}_updateOutputs(t){}registerDataInput(t,r,e){let n=new p(t,0,this,r,e);return this.dataInputs.push(n),n}registerDataOutput(t,r,e){let n=new p(t,1,this,r,e);return this.dataOutputs.push(n),n}getDataInput(t){return this.dataInputs.find(r=>r.name===t)}getDataOutput(t){return this.dataOutputs.find(r=>r.name===t)}serialize(t={},r=I){if(t.uniqueId=this.uniqueId,t.config={},this.config){let e=this.config,n=Object.keys(e);for(let i of n)r(i,e[i],t.config)}t.dataInputs=[],t.dataOutputs=[],t.className=this.getClassName();for(let e of this.dataInputs){let n={};e.serialize(n),t.dataInputs.push(n)}for(let e of this.dataOutputs){let n={};e.serialize(n),t.dataOutputs.push(n)}}deserialize(t){}_log(t,r,e){t.logger?.addLogItem({action:r,payload:e,className:this.getClassName(),uniqueId:this.uniqueId})}getClassName(){return"FlowGraphBlock"}};export{g as a,l as b,d as c,C as d,S as e,R as f,B as g,b as h,A as i,G as j,P as k,Q as l,E as m,T as n,k as o,rt as p,L as q,nt as r,ot as s,I as t,K as u,mt as v,D as w,v as x};
